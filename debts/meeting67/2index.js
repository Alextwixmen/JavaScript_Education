// 1. Что такое this?

// - Динамический объект контекст. Динамический засчет того, что, значение this может быть разным в одной и той же функици.
//  Все зависит от того, каким объектом она вызывается. Контекст указывает на объект, который его вызывает до точки. object.this
// В 99% случаев значение, которое мы получаем через this, является объектом.


// 2. Что будет с кодом ниже? 
const user = {
  sayHi: function() {
    this.sayHi();
  }
};
user.sayHi()
// Вот что нагуглил:
// Это означает, что где-то в вашем коде вы вызываете функцию, которая, в свою очередь, вызывает другую функцию и так далее, пока вы не достигнете предела стека вызовов.
// Это почти всегда происходит из-за рекурсивной функции с базовым вариантом, который не выполняется.
// Что понял: типо бесконечный вызов, но в пределах памяти, так как она не бесконечна же. Рекурсию не смотрел, поэтому так пока понимаю.
// Для решения этой бесконечной валакиты рекурсивная функция должна иметь базовый вариант, который будет выполнен. 


// 3. Почему typeof somefunction возвращает function, а не объект? Если функция является объектом. 
// Так определно в спецификации ECMAScript, хз что еще тут сказть.
// source: https://262.ecma-international.org/5.1/#sec-11.4.3
// Что-то интересное с typeof:
typeof null === 'object'// true. Баг js, который никогда не будет исправлен. 

// 4. Приведение при помоще Number(что-то, что хотим привести к числу). Number - функция, результатом котороый является значение, которое приобразуется в числу.
// На примере prompt: по дефолту там строка, но с Number(prompt("введите число")) нам вернется число и с ним можно работать уже как с числом. 

// 5. Операторы || && 
// Доразобрался. 
// Из важного и того, что точно забыл: приоритет && выше, чем у ||. Например:

console.log(1 && 5 || 3 && 4)
// 1. Сначала сравнивт 1 и 5 и вернет 5, так как возвращает последнее истинное в данном случае.
// 2. Вернет 4 по той же причине.
// 3. При сравнении 5 и 4 вернет первое истинное, то есть 5. 

// 6. Повторил оператор ! и !!
// ! -  приводит значение к булевому и возвращает обратное.
// for ex:
let a = 1 > 2;
console.log(a)// false
console.log(!a)// true
// !! - таким образом любое значение можно привести к булевому. То есть он сначала приводит к обратному при помощь первого "!", 
// а потом опять приводит назад при помощи второго "!"
let b = 1;
console.log(!!b)// true
let c = 0;
console.log(!!c) // false

// 7. Будет ошибка или нет? Если нет, то сколько раз он выполнится?
for(; ;){}; // бесконечность. Проверил при помощи run code в ide:)) А как иначе проверить?


// 8. Почитать про switch. Попробовать использовать default первым перед case, а не в конце.
// Конструкция switch заменяет собой сразу несколько if.
// Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.

// 9. Тернарный оператор. 
Единственный оператор, имеющий 3 аргумента. Поэтому 1 ? 2 выдаст ошибку.
// a ? b: c
// Если а равно true, то верни b. Иначе верни c.
// двоеточние тут не является оператором, опертор восклицательный знак, просто у него синтаксис с двоеточнием, чтобы разделить 1-ый, 2-ой и 3-й аргумент.
let q = +prompt("Введите ваш возраст");
zoomer = 'поздравляю! Вы - зумер';
melenial = 'Мелениал';
q < 20? zoomer: melenial;